{"ast":null,"code":"import interpolateNode from '../reanimated1/derived/interpolate';\nexport var Extrapolation;\n(function (Extrapolation) {\n  Extrapolation[\"IDENTITY\"] = \"identity\";\n  Extrapolation[\"CLAMP\"] = \"clamp\";\n  Extrapolation[\"EXTEND\"] = \"extend\";\n})(Extrapolation || (Extrapolation = {}));\nconst isNode = function () {\n  const _f = function (x) {\n    return x.__nodeId !== undefined;\n  };\n  _f._closure = {};\n  _f.asString = \"function isNode(x){return x.__nodeId!==undefined;}\";\n  _f.__workletHash = 11428170322833;\n  _f.__location = \"C:\\\\Users\\\\jsh4f\\\\OneDrive\\\\Documents\\\\GitHub\\\\UDL\\\\node_modules\\\\react-native-reanimated\\\\lib\\\\reanimated2\\\\interpolation.js (9:0)\";\n  return _f;\n}();\nconst getVal = function () {\n  const _f = function (type, coef, val, leftEdgeOutput, rightEdgeOutput, x) {\n    switch (type) {\n      case Extrapolation.IDENTITY:\n        return x;\n      case Extrapolation.CLAMP:\n        if (coef * val < coef * leftEdgeOutput) {\n          return leftEdgeOutput;\n        }\n        return rightEdgeOutput;\n      case Extrapolation.EXTEND:\n      default:\n        return val;\n    }\n  };\n  _f._closure = {\n    Extrapolation: {\n      IDENTITY: Extrapolation.IDENTITY,\n      CLAMP: Extrapolation.CLAMP,\n      EXTEND: Extrapolation.EXTEND\n    }\n  };\n  _f.asString = \"function getVal(type,coef,val,leftEdgeOutput,rightEdgeOutput,x){const{Extrapolation}=jsThis._closure;{switch(type){case Extrapolation.IDENTITY:return x;case Extrapolation.CLAMP:if(coef*val<coef*leftEdgeOutput){return leftEdgeOutput;}return rightEdgeOutput;case Extrapolation.EXTEND:default:return val;}}}\";\n  _f.__workletHash = 17254780971327;\n  _f.__location = \"C:\\\\Users\\\\jsh4f\\\\OneDrive\\\\Documents\\\\GitHub\\\\UDL\\\\node_modules\\\\react-native-reanimated\\\\lib\\\\reanimated2\\\\interpolation.js (13:0)\";\n  return _f;\n}();\nconst isExtrapolate = function () {\n  const _f = function (value) {\n    return value === Extrapolation.EXTEND || value === Extrapolation.CLAMP || value === Extrapolation.IDENTITY;\n  };\n  _f._closure = {\n    Extrapolation: {\n      EXTEND: Extrapolation.EXTEND,\n      CLAMP: Extrapolation.CLAMP,\n      IDENTITY: Extrapolation.IDENTITY\n    }\n  };\n  _f.asString = \"function isExtrapolate(value){const{Extrapolation}=jsThis._closure;{return value===Extrapolation.EXTEND||value===Extrapolation.CLAMP||value===Extrapolation.IDENTITY;}}\";\n  _f.__workletHash = 10218308201564;\n  _f.__location = \"C:\\\\Users\\\\jsh4f\\\\OneDrive\\\\Documents\\\\GitHub\\\\UDL\\\\node_modules\\\\react-native-reanimated\\\\lib\\\\reanimated2\\\\interpolation.js (28:0)\";\n  return _f;\n}();\nconst validateType = function () {\n  const _f = function (type) {\n    const extrapolationConfig = {\n      extrapolateLeft: Extrapolation.EXTEND,\n      extrapolateRight: Extrapolation.EXTEND\n    };\n    if (!type) {\n      return extrapolationConfig;\n    }\n    if (typeof type === 'string') {\n      if (!isExtrapolate(type)) {\n        throw new Error(`Reanimated: not supported value for \"interpolate\" \\nSupported values: [\"extend\", \"clamp\", \"identity\", Extrapolatation.CLAMP, Extrapolatation.EXTEND, Extrapolatation.IDENTITY]\\n Valid example:\n        interpolate(value, [inputRange], [outputRange], \"clamp\")`);\n      }\n      extrapolationConfig.extrapolateLeft = type;\n      extrapolationConfig.extrapolateRight = type;\n      return extrapolationConfig;\n    }\n    if (type.extrapolateLeft && !isExtrapolate(type.extrapolateLeft) || type.extrapolateRight && !isExtrapolate(type.extrapolateRight)) {\n      throw new Error(`Reanimated: not supported value for \"interpolate\" \\nSupported values: [\"extend\", \"clamp\", \"identity\", Extrapolatation.CLAMP, Extrapolatation.EXTEND, Extrapolatation.IDENTITY]\\n Valid example:\n      interpolate(value, [inputRange], [outputRange], {\n        extrapolateLeft: Extrapolation.CLAMP,\n        extrapolateRight: Extrapolation.IDENTITY\n      }})`);\n    }\n    Object.assign(extrapolationConfig, type);\n    return extrapolationConfig;\n  };\n  _f._closure = {\n    Extrapolation: {\n      EXTEND: Extrapolation.EXTEND\n    },\n    isExtrapolate\n  };\n  _f.asString = \"function validateType(type){const{Extrapolation,isExtrapolate}=jsThis._closure;{const extrapolationConfig={extrapolateLeft:Extrapolation.EXTEND,extrapolateRight:Extrapolation.EXTEND};if(!type){return extrapolationConfig;}if(typeof type==='string'){if(!isExtrapolate(type)){throw new Error(\\\"Reanimated: not supported value for \\\\\\\"interpolate\\\\\\\" \\\\nSupported values: [\\\\\\\"extend\\\\\\\", \\\\\\\"clamp\\\\\\\", \\\\\\\"identity\\\\\\\", Extrapolatation.CLAMP, Extrapolatation.EXTEND, Extrapolatation.IDENTITY]\\\\n Valid example:\\\\n        interpolate(value, [inputRange], [outputRange], \\\\\\\"clamp\\\\\\\")\\\");}extrapolationConfig.extrapolateLeft=type;extrapolationConfig.extrapolateRight=type;return extrapolationConfig;}if(type.extrapolateLeft&&!isExtrapolate(type.extrapolateLeft)||type.extrapolateRight&&!isExtrapolate(type.extrapolateRight)){throw new Error(\\\"Reanimated: not supported value for \\\\\\\"interpolate\\\\\\\" \\\\nSupported values: [\\\\\\\"extend\\\\\\\", \\\\\\\"clamp\\\\\\\", \\\\\\\"identity\\\\\\\", Extrapolatation.CLAMP, Extrapolatation.EXTEND, Extrapolatation.IDENTITY]\\\\n Valid example:\\\\n      interpolate(value, [inputRange], [outputRange], {\\\\n        extrapolateLeft: Extrapolation.CLAMP,\\\\n        extrapolateRight: Extrapolation.IDENTITY\\\\n      }})\\\");}Object.assign(extrapolationConfig,type);return extrapolationConfig;}}\";\n  _f.__workletHash = 7740971206170;\n  _f.__location = \"C:\\\\Users\\\\jsh4f\\\\OneDrive\\\\Documents\\\\GitHub\\\\UDL\\\\node_modules\\\\react-native-reanimated\\\\lib\\\\reanimated2\\\\interpolation.js (36:0)\";\n  return _f;\n}();\nconst internalInterpolate = function () {\n  const _f = function (x, narrowedInput, extrapolationConfig) {\n    const {\n      leftEdgeInput,\n      rightEdgeInput,\n      leftEdgeOutput,\n      rightEdgeOutput\n    } = narrowedInput;\n    if (rightEdgeInput - leftEdgeInput === 0) return leftEdgeOutput;\n    const progress = (x - leftEdgeInput) / (rightEdgeInput - leftEdgeInput);\n    const val = leftEdgeOutput + progress * (rightEdgeOutput - leftEdgeOutput);\n    const coef = rightEdgeOutput >= leftEdgeOutput ? 1 : -1;\n    if (coef * val < coef * leftEdgeOutput) {\n      return getVal(extrapolationConfig.extrapolateLeft, coef, val, leftEdgeOutput, rightEdgeOutput, x);\n    } else if (coef * val > coef * rightEdgeOutput) {\n      return getVal(extrapolationConfig.extrapolateRight, coef, val, leftEdgeOutput, rightEdgeOutput, x);\n    }\n    return val;\n  };\n  _f._closure = {\n    getVal\n  };\n  _f.asString = \"function internalInterpolate(x,narrowedInput,extrapolationConfig){const{getVal}=jsThis._closure;{const{leftEdgeInput:leftEdgeInput,rightEdgeInput:rightEdgeInput,leftEdgeOutput:leftEdgeOutput,rightEdgeOutput:rightEdgeOutput}=narrowedInput;if(rightEdgeInput-leftEdgeInput===0)return leftEdgeOutput;const progress=(x-leftEdgeInput)/(rightEdgeInput-leftEdgeInput);const val=leftEdgeOutput+progress*(rightEdgeOutput-leftEdgeOutput);const coef=rightEdgeOutput>=leftEdgeOutput?1:-1;if(coef*val<coef*leftEdgeOutput){return getVal(extrapolationConfig.extrapolateLeft,coef,val,leftEdgeOutput,rightEdgeOutput,x);}else if(coef*val>coef*rightEdgeOutput){return getVal(extrapolationConfig.extrapolateRight,coef,val,leftEdgeOutput,rightEdgeOutput,x);}return val;}}\";\n  _f.__workletHash = 8108992359068;\n  _f.__location = \"C:\\\\Users\\\\jsh4f\\\\OneDrive\\\\Documents\\\\GitHub\\\\UDL\\\\node_modules\\\\react-native-reanimated\\\\lib\\\\reanimated2\\\\interpolation.js (67:0)\";\n  return _f;\n}();\nexport const interpolate = function () {\n  const _f = function (x, input, output, type) {\n    if (input.length < 2 || output.length < 2) {\n      throw Error('Interpolation input and output should contain at least two values.');\n    }\n    const extrapolationConfig = validateType(type);\n    if (isNode(x)) {\n      console.warn(`interpolate() was renamed to interpolateNode() in Reanimated 2. Please use interpolateNode() instead`);\n      return interpolateNode(x, {\n        inputRange: input,\n        outputRange: output,\n        extrapolateLeft: extrapolationConfig.extrapolateLeft,\n        extrapolateRight: extrapolationConfig.extrapolateRight\n      });\n    }\n    const length = input.length;\n    const narrowedInput = {\n      leftEdgeInput: input[0],\n      rightEdgeInput: input[1],\n      leftEdgeOutput: output[0],\n      rightEdgeOutput: output[1]\n    };\n    if (length > 2) {\n      if (x > input[length - 1]) {\n        narrowedInput.leftEdgeInput = input[length - 2];\n        narrowedInput.rightEdgeInput = input[length - 1];\n        narrowedInput.leftEdgeOutput = output[length - 2];\n        narrowedInput.rightEdgeOutput = output[length - 1];\n      } else {\n        for (let i = 1; i < length; ++i) {\n          if (x <= input[i]) {\n            narrowedInput.leftEdgeInput = input[i - 1];\n            narrowedInput.rightEdgeInput = input[i];\n            narrowedInput.leftEdgeOutput = output[i - 1];\n            narrowedInput.rightEdgeOutput = output[i];\n            break;\n          }\n        }\n      }\n    }\n    return internalInterpolate(x, narrowedInput, extrapolationConfig);\n  };\n  _f._closure = {\n    validateType,\n    isNode,\n    interpolateNode,\n    internalInterpolate\n  };\n  _f.asString = \"function interpolate(x,input,output,type){const{validateType,isNode,interpolateNode,internalInterpolate}=jsThis._closure;{if(input.length<2||output.length<2){throw Error('Interpolation input and output should contain at least two values.');}const extrapolationConfig=validateType(type);if(isNode(x)){console.warn(\\\"interpolate() was renamed to interpolateNode() in Reanimated 2. Please use interpolateNode() instead\\\");return interpolateNode(x,{inputRange:input,outputRange:output,extrapolateLeft:extrapolationConfig.extrapolateLeft,extrapolateRight:extrapolationConfig.extrapolateRight});}const length=input.length;const narrowedInput={leftEdgeInput:input[0],rightEdgeInput:input[1],leftEdgeOutput:output[0],rightEdgeOutput:output[1]};if(length>2){if(x>input[length-1]){narrowedInput.leftEdgeInput=input[length-2];narrowedInput.rightEdgeInput=input[length-1];narrowedInput.leftEdgeOutput=output[length-2];narrowedInput.rightEdgeOutput=output[length-1];}else{for(let i=1;i<length;++i){if(x<=input[i]){narrowedInput.leftEdgeInput=input[i-1];narrowedInput.rightEdgeInput=input[i];narrowedInput.leftEdgeOutput=output[i-1];narrowedInput.rightEdgeOutput=output[i];break;}}}}return internalInterpolate(x,narrowedInput,extrapolationConfig);}}\";\n  _f.__workletHash = 14201461170439;\n  _f.__location = \"C:\\\\Users\\\\jsh4f\\\\OneDrive\\\\Documents\\\\GitHub\\\\UDL\\\\node_modules\\\\react-native-reanimated\\\\lib\\\\reanimated2\\\\interpolation.js (85:7)\";\n  return _f;\n}();","map":{"version":3,"names":["interpolateNode","Extrapolation","isNode","_f","x","__nodeId","undefined","_closure","asString","__workletHash","__location","getVal","type","coef","val","leftEdgeOutput","rightEdgeOutput","IDENTITY","CLAMP","EXTEND","isExtrapolate","value","validateType","extrapolationConfig","extrapolateLeft","extrapolateRight","Error","Object","assign","internalInterpolate","narrowedInput","leftEdgeInput","rightEdgeInput","progress","interpolate","input","output","length","console","warn","inputRange","outputRange","i"],"sources":["C:/Users/jsh4f/OneDrive/Documents/GitHub/UDL/node_modules/react-native-reanimated/lib/reanimated2/interpolation.js"],"sourcesContent":["// @ts-ignore JS file\nimport interpolateNode from '../reanimated1/derived/interpolate';\nexport var Extrapolation;\n(function (Extrapolation) {\n    Extrapolation[\"IDENTITY\"] = \"identity\";\n    Extrapolation[\"CLAMP\"] = \"clamp\";\n    Extrapolation[\"EXTEND\"] = \"extend\";\n})(Extrapolation || (Extrapolation = {}));\nfunction isNode(x) {\n    'worklet';\n    return x.__nodeId !== undefined;\n}\nfunction getVal(type, coef, val, leftEdgeOutput, rightEdgeOutput, x) {\n    'worklet';\n    switch (type) {\n        case Extrapolation.IDENTITY:\n            return x;\n        case Extrapolation.CLAMP:\n            if (coef * val < coef * leftEdgeOutput) {\n                return leftEdgeOutput;\n            }\n            return rightEdgeOutput;\n        case Extrapolation.EXTEND:\n        default:\n            return val;\n    }\n}\nfunction isExtrapolate(value) {\n    'worklet';\n    return (value === Extrapolation.EXTEND ||\n        value === Extrapolation.CLAMP ||\n        value === Extrapolation.IDENTITY);\n}\n// validates extrapolations type\n// if type is correct, converts it to ExtrapolationConfig\nfunction validateType(type) {\n    'worklet';\n    // initialize extrapolationConfig with default extrapolation\n    const extrapolationConfig = {\n        extrapolateLeft: Extrapolation.EXTEND,\n        extrapolateRight: Extrapolation.EXTEND,\n    };\n    if (!type) {\n        return extrapolationConfig;\n    }\n    if (typeof type === 'string') {\n        if (!isExtrapolate(type)) {\n            throw new Error(`Reanimated: not supported value for \"interpolate\" \\nSupported values: [\"extend\", \"clamp\", \"identity\", Extrapolatation.CLAMP, Extrapolatation.EXTEND, Extrapolatation.IDENTITY]\\n Valid example:\n        interpolate(value, [inputRange], [outputRange], \"clamp\")`);\n        }\n        extrapolationConfig.extrapolateLeft = type;\n        extrapolationConfig.extrapolateRight = type;\n        return extrapolationConfig;\n    }\n    // otherwise type is extrapolation config object\n    if ((type.extrapolateLeft && !isExtrapolate(type.extrapolateLeft)) ||\n        (type.extrapolateRight && !isExtrapolate(type.extrapolateRight))) {\n        throw new Error(`Reanimated: not supported value for \"interpolate\" \\nSupported values: [\"extend\", \"clamp\", \"identity\", Extrapolatation.CLAMP, Extrapolatation.EXTEND, Extrapolatation.IDENTITY]\\n Valid example:\n      interpolate(value, [inputRange], [outputRange], {\n        extrapolateLeft: Extrapolation.CLAMP,\n        extrapolateRight: Extrapolation.IDENTITY\n      }})`);\n    }\n    Object.assign(extrapolationConfig, type);\n    return extrapolationConfig;\n}\nfunction internalInterpolate(x, narrowedInput, extrapolationConfig) {\n    'worklet';\n    const { leftEdgeInput, rightEdgeInput, leftEdgeOutput, rightEdgeOutput } = narrowedInput;\n    if (rightEdgeInput - leftEdgeInput === 0)\n        return leftEdgeOutput;\n    const progress = (x - leftEdgeInput) / (rightEdgeInput - leftEdgeInput);\n    const val = leftEdgeOutput + progress * (rightEdgeOutput - leftEdgeOutput);\n    const coef = rightEdgeOutput >= leftEdgeOutput ? 1 : -1;\n    if (coef * val < coef * leftEdgeOutput) {\n        return getVal(extrapolationConfig.extrapolateLeft, coef, val, leftEdgeOutput, rightEdgeOutput, x);\n    }\n    else if (coef * val > coef * rightEdgeOutput) {\n        return getVal(extrapolationConfig.extrapolateRight, coef, val, leftEdgeOutput, rightEdgeOutput, x);\n    }\n    return val;\n}\n// TODO: support default values in worklets:\n// e.g. function interpolate(x, input, output, type = Extrapolatation.CLAMP)\nexport function interpolate(x, input, output, type) {\n    'worklet';\n    if (input.length < 2 || output.length < 2) {\n        throw Error('Interpolation input and output should contain at least two values.');\n    }\n    const extrapolationConfig = validateType(type);\n    if (isNode(x)) {\n        console.warn(`interpolate() was renamed to interpolateNode() in Reanimated 2. Please use interpolateNode() instead`);\n        return interpolateNode(x, {\n            inputRange: input,\n            outputRange: output,\n            extrapolateLeft: extrapolationConfig.extrapolateLeft,\n            extrapolateRight: extrapolationConfig.extrapolateRight,\n        });\n    }\n    const length = input.length;\n    const narrowedInput = {\n        leftEdgeInput: input[0],\n        rightEdgeInput: input[1],\n        leftEdgeOutput: output[0],\n        rightEdgeOutput: output[1],\n    };\n    if (length > 2) {\n        if (x > input[length - 1]) {\n            narrowedInput.leftEdgeInput = input[length - 2];\n            narrowedInput.rightEdgeInput = input[length - 1];\n            narrowedInput.leftEdgeOutput = output[length - 2];\n            narrowedInput.rightEdgeOutput = output[length - 1];\n        }\n        else {\n            for (let i = 1; i < length; ++i) {\n                if (x <= input[i]) {\n                    narrowedInput.leftEdgeInput = input[i - 1];\n                    narrowedInput.rightEdgeInput = input[i];\n                    narrowedInput.leftEdgeOutput = output[i - 1];\n                    narrowedInput.rightEdgeOutput = output[i];\n                    break;\n                }\n            }\n        }\n    }\n    return internalInterpolate(x, narrowedInput, extrapolationConfig);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}